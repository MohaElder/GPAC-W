{"version":3,"sources":["punycode.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["'use strict';\r\n\r\n/** Highest positive signed 32-bit float value */\r\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\r\n\r\n/** Bootstring parameters */\r\nconst base = 36;\r\nconst tMin = 1;\r\nconst tMax = 26;\r\nconst skew = 38;\r\nconst damp = 700;\r\nconst initialBias = 72;\r\nconst initialN = 128; // 0x80\r\nconst delimiter = '-'; // '\\x2D'\r\n\r\n/** Regular expressions */\r\nconst regexPunycode = /^xn--/;\r\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\r\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\r\n\r\n/** Error messages */\r\nconst errors = {\r\n\t'overflow': 'Overflow: input needs wider integers to process',\r\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\r\n\t'invalid-input': 'Invalid input'\r\n};\r\n\r\n/** Convenience shortcuts */\r\nconst baseMinusTMin = base - tMin;\r\nconst floor = Math.floor;\r\nconst stringFromCharCode = String.fromCharCode;\r\n\r\n/*--------------------------------------------------------------------------*/\r\n\r\n/**\r\n * A generic error utility function.\r\n * @private\r\n * @param {String} type The error type.\r\n * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n */\r\nfunction error(type) {\r\n\tthrow new RangeError(errors[type]);\r\n}\r\n\r\n/**\r\n * A generic `Array#map` utility function.\r\n * @private\r\n * @param {Array} array The array to iterate over.\r\n * @param {Function} callback The function that gets called for every array\r\n * item.\r\n * @returns {Array} A new array of values returned by the callback function.\r\n */\r\nfunction map(array, fn) {\r\n\tconst result = [];\r\n\tlet length = array.length;\r\n\twhile (length--) {\r\n\t\tresult[length] = fn(array[length]);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * A simple `Array#map`-like wrapper to work with domain name strings or email\r\n * addresses.\r\n * @private\r\n * @param {String} domain The domain name or email address.\r\n * @param {Function} callback The function that gets called for every\r\n * character.\r\n * @returns {Array} A new string of characters returned by the callback\r\n * function.\r\n */\r\nfunction mapDomain(string, fn) {\r\n\tconst parts = string.split('@');\r\n\tlet result = '';\r\n\tif (parts.length > 1) {\r\n\t\t// In email addresses, only the domain name should be punycoded. Leave\r\n\t\t// the local part (i.e. everything up to `@`) intact.\r\n\t\tresult = parts[0] + '@';\r\n\t\tstring = parts[1];\r\n\t}\r\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\r\n\tstring = string.replace(regexSeparators, '\\x2E');\r\n\tconst labels = string.split('.');\r\n\tconst encoded = map(labels, fn).join('.');\r\n\treturn result + encoded;\r\n}\r\n\r\n/**\r\n * Creates an array containing the numeric code points of each Unicode\r\n * character in the string. While JavaScript uses UCS-2 internally,\r\n * this function will convert a pair of surrogate halves (each of which\r\n * UCS-2 exposes as separate characters) into a single code point,\r\n * matching UTF-16.\r\n * @see `punycode.ucs2.encode`\r\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n * @memberOf punycode.ucs2\r\n * @name decode\r\n * @param {String} string The Unicode input string (UCS-2).\r\n * @returns {Array} The new array of code points.\r\n */\r\nfunction ucs2decode(string) {\r\n\tconst output = [];\r\n\tlet counter = 0;\r\n\tconst length = string.length;\r\n\twhile (counter < length) {\r\n\t\tconst value = string.charCodeAt(counter++);\r\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\r\n\t\t\t// It's a high surrogate, and there is a next character.\r\n\t\t\tconst extra = string.charCodeAt(counter++);\r\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\r\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\r\n\t\t\t} else {\r\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\r\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\r\n\t\t\t\toutput.push(value);\r\n\t\t\t\tcounter--;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\toutput.push(value);\r\n\t\t}\r\n\t}\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Creates a string based on an array of numeric code points.\r\n * @see `punycode.ucs2.decode`\r\n * @memberOf punycode.ucs2\r\n * @name encode\r\n * @param {Array} codePoints The array of numeric code points.\r\n * @returns {String} The new Unicode string (UCS-2).\r\n */\r\nconst ucs2encode = array => String.fromCodePoint(...array);\r\n\r\n/**\r\n * Converts a basic code point into a digit/integer.\r\n * @see `digitToBasic()`\r\n * @private\r\n * @param {Number} codePoint The basic numeric code point value.\r\n * @returns {Number} The numeric value of a basic code point (for use in\r\n * representing integers) in the range `0` to `base - 1`, or `base` if\r\n * the code point does not represent a value.\r\n */\r\nconst basicToDigit = function(codePoint) {\r\n\tif (codePoint - 0x30 < 0x0A) {\r\n\t\treturn codePoint - 0x16;\r\n\t}\r\n\tif (codePoint - 0x41 < 0x1A) {\r\n\t\treturn codePoint - 0x41;\r\n\t}\r\n\tif (codePoint - 0x61 < 0x1A) {\r\n\t\treturn codePoint - 0x61;\r\n\t}\r\n\treturn base;\r\n};\r\n\r\n/**\r\n * Converts a digit/integer into a basic code point.\r\n * @see `basicToDigit()`\r\n * @private\r\n * @param {Number} digit The numeric value of a basic code point.\r\n * @returns {Number} The basic code point whose value (when used for\r\n * representing integers) is `digit`, which needs to be in the range\r\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n * used; else, the lowercase form is used. The behavior is undefined\r\n * if `flag` is non-zero and `digit` has no uppercase form.\r\n */\r\nconst digitToBasic = function(digit, flag) {\r\n\t//  0..25 map to ASCII a..z or A..Z\r\n\t// 26..35 map to ASCII 0..9\r\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\r\n};\r\n\r\n/**\r\n * Bias adaptation function as per section 3.4 of RFC 3492.\r\n * https://tools.ietf.org/html/rfc3492#section-3.4\r\n * @private\r\n */\r\nconst adapt = function(delta, numPoints, firstTime) {\r\n\tlet k = 0;\r\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\r\n\tdelta += floor(delta / numPoints);\r\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\r\n\t\tdelta = floor(delta / baseMinusTMin);\r\n\t}\r\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\r\n};\r\n\r\n/**\r\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n * symbols.\r\n * @memberOf punycode\r\n * @param {String} input The Punycode string of ASCII-only symbols.\r\n * @returns {String} The resulting string of Unicode symbols.\r\n */\r\nconst decode = function(input) {\r\n\t// Don't use UCS-2.\r\n\tconst output = [];\r\n\tconst inputLength = input.length;\r\n\tlet i = 0;\r\n\tlet n = initialN;\r\n\tlet bias = initialBias;\r\n\r\n\t// Handle the basic code points: let `basic` be the number of input code\r\n\t// points before the last delimiter, or `0` if there is none, then copy\r\n\t// the first basic code points to the output.\r\n\r\n\tlet basic = input.lastIndexOf(delimiter);\r\n\tif (basic < 0) {\r\n\t\tbasic = 0;\r\n\t}\r\n\r\n\tfor (let j = 0; j < basic; ++j) {\r\n\t\t// if it's not a basic code point\r\n\t\tif (input.charCodeAt(j) >= 0x80) {\r\n\t\t\terror('not-basic');\r\n\t\t}\r\n\t\toutput.push(input.charCodeAt(j));\r\n\t}\r\n\r\n\t// Main decoding loop: start just after the last delimiter if any basic code\r\n\t// points were copied; start at the beginning otherwise.\r\n\r\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\r\n\r\n\t\t// `index` is the index of the next character to be consumed.\r\n\t\t// Decode a generalized variable-length integer into `delta`,\r\n\t\t// which gets added to `i`. The overflow checking is easier\r\n\t\t// if we increase `i` as we go, then subtract off its starting\r\n\t\t// value at the end to obtain `delta`.\r\n\t\tlet oldi = i;\r\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\r\n\r\n\t\t\tif (index >= inputLength) {\r\n\t\t\t\terror('invalid-input');\r\n\t\t\t}\r\n\r\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\r\n\r\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\ti += digit * w;\r\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\r\n\t\t\tif (digit < t) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tconst baseMinusT = base - t;\r\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tw *= baseMinusT;\r\n\r\n\t\t}\r\n\r\n\t\tconst out = output.length + 1;\r\n\t\tbias = adapt(i - oldi, out, oldi == 0);\r\n\r\n\t\t// `i` was supposed to wrap around from `out` to `0`,\r\n\t\t// incrementing `n` each time, so we'll fix that now:\r\n\t\tif (floor(i / out) > maxInt - n) {\r\n\t\t\terror('overflow');\r\n\t\t}\r\n\r\n\t\tn += floor(i / out);\r\n\t\ti %= out;\r\n\r\n\t\t// Insert `n` at position `i` of the output.\r\n\t\toutput.splice(i++, 0, n);\r\n\r\n\t}\r\n\r\n\treturn String.fromCodePoint(...output);\r\n};\r\n\r\n/**\r\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n * Punycode string of ASCII-only symbols.\r\n * @memberOf punycode\r\n * @param {String} input The string of Unicode symbols.\r\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n */\r\nconst encode = function(input) {\r\n\tconst output = [];\r\n\r\n\t// Convert the input in UCS-2 to an array of Unicode code points.\r\n\tinput = ucs2decode(input);\r\n\r\n\t// Cache the length.\r\n\tlet inputLength = input.length;\r\n\r\n\t// Initialize the state.\r\n\tlet n = initialN;\r\n\tlet delta = 0;\r\n\tlet bias = initialBias;\r\n\r\n\t// Handle the basic code points.\r\n\tfor (const currentValue of input) {\r\n\t\tif (currentValue < 0x80) {\r\n\t\t\toutput.push(stringFromCharCode(currentValue));\r\n\t\t}\r\n\t}\r\n\r\n\tlet basicLength = output.length;\r\n\tlet handledCPCount = basicLength;\r\n\r\n\t// `handledCPCount` is the number of code points that have been handled;\r\n\t// `basicLength` is the number of basic code points.\r\n\r\n\t// Finish the basic string with a delimiter unless it's empty.\r\n\tif (basicLength) {\r\n\t\toutput.push(delimiter);\r\n\t}\r\n\r\n\t// Main encoding loop:\r\n\twhile (handledCPCount < inputLength) {\r\n\r\n\t\t// All non-basic code points < n have been handled already. Find the next\r\n\t\t// larger one:\r\n\t\tlet m = maxInt;\r\n\t\tfor (const currentValue of input) {\r\n\t\t\tif (currentValue >= n && currentValue < m) {\r\n\t\t\t\tm = currentValue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\r\n\t\t// but guard against overflow.\r\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\r\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\r\n\t\t\terror('overflow');\r\n\t\t}\r\n\r\n\t\tdelta += (m - n) * handledCPCountPlusOne;\r\n\t\tn = m;\r\n\r\n\t\tfor (const currentValue of input) {\r\n\t\t\tif (currentValue < n && ++delta > maxInt) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\t\t\tif (currentValue == n) {\r\n\t\t\t\t// Represent delta as a generalized variable-length integer.\r\n\t\t\t\tlet q = delta;\r\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\r\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\t\t\t\t\tif (q < t) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst qMinusT = q - t;\r\n\t\t\t\t\tconst baseMinusT = base - t;\r\n\t\t\t\t\toutput.push(\r\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\r\n\t\t\t\t\t);\r\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\r\n\t\t\t\t}\r\n\r\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\r\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\r\n\t\t\t\tdelta = 0;\r\n\t\t\t\t++handledCPCount;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t++delta;\r\n\t\t++n;\r\n\r\n\t}\r\n\treturn output.join('');\r\n};\r\n\r\n/**\r\n * Converts a Punycode string representing a domain name or an email address\r\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n * it doesn't matter if you call it on a string that has already been\r\n * converted to Unicode.\r\n * @memberOf punycode\r\n * @param {String} input The Punycoded domain name or email address to\r\n * convert to Unicode.\r\n * @returns {String} The Unicode representation of the given Punycode\r\n * string.\r\n */\r\nconst toUnicode = function(input) {\r\n\treturn mapDomain(input, function(string) {\r\n\t\treturn regexPunycode.test(string)\r\n\t\t\t? decode(string.slice(4).toLowerCase())\r\n\t\t\t: string;\r\n\t});\r\n};\r\n\r\n/**\r\n * Converts a Unicode string representing a domain name or an email address to\r\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n * i.e. it doesn't matter if you call it with a domain that's already in\r\n * ASCII.\r\n * @memberOf punycode\r\n * @param {String} input The domain name or email address to convert, as a\r\n * Unicode string.\r\n * @returns {String} The Punycode representation of the given domain name or\r\n * email address.\r\n */\r\nconst toASCII = function(input) {\r\n\treturn mapDomain(input, function(string) {\r\n\t\treturn regexNonASCII.test(string)\r\n\t\t\t? 'xn--' + encode(string)\r\n\t\t\t: string;\r\n\t});\r\n};\r\n\r\n/*--------------------------------------------------------------------------*/\r\n\r\n/** Define the public API */\r\nconst punycode = {\r\n\t/**\r\n\t * A string representing the current Punycode.js version number.\r\n\t * @memberOf punycode\r\n\t * @type String\r\n\t */\r\n\t'version': '2.1.0',\r\n\t/**\r\n\t * An object of methods to convert from JavaScript's internal character\r\n\t * representation (UCS-2) to Unicode code points, and back.\r\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n\t * @memberOf punycode\r\n\t * @type Object\r\n\t */\r\n\t'ucs2': {\r\n\t\t'decode': ucs2decode,\r\n\t\t'encode': ucs2encode\r\n\t},\r\n\t'decode': decode,\r\n\t'encode': encode,\r\n\t'toASCII': toASCII,\r\n\t'toUnicode': toUnicode\r\n};\r\n\r\nmodule.exports = punycode;\r\n"]}